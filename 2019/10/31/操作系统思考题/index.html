<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="第一次思考题： 1，为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？    因为CPU只能运行内存中的程序，而在计算机启动最开始的时候，RAM中什么都没有，操作系统代码存放在软盘中，无法直接运行；BIOS代码的执行是靠硬件实现的，它被固化在计算机中的ROM芯片里。 2，为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统思考题">
<meta property="og:url" content="http://yoursite.com/2019/10/31/操作系统思考题/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description" content="第一次思考题： 1，为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？    因为CPU只能运行内存中的程序，而在计算机启动最开始的时候，RAM中什么都没有，操作系统代码存放在软盘中，无法直接运行；BIOS代码的执行是靠硬件实现的，它被固化在计算机中的ROM芯片里。 2，为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="c:/Users/我的电脑/AppData/Roaming/Typora/typora-user-images/1571904362530.png">
<meta property="og:image" content="c:/Users/我的电脑/AppData/Roaming/Typora/typora-user-images/1572108499756.png">
<meta property="og:image" content="c:/Users/我的电脑/AppData/Roaming/Typora/typora-user-images/image-20191027194859638.png">
<meta property="og:updated_time" content="2019-10-31T02:46:54.322Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统思考题">
<meta name="twitter:description" content="第一次思考题： 1，为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？    因为CPU只能运行内存中的程序，而在计算机启动最开始的时候，RAM中什么都没有，操作系统代码存放在软盘中，无法直接运行；BIOS代码的执行是靠硬件实现的，它被固化在计算机中的ROM芯片里。 2，为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载">
<meta name="twitter:image" content="c:/Users/我的电脑/AppData/Roaming/Typora/typora-user-images/1571904362530.png">






  <link rel="canonical" href="http://yoursite.com/2019/10/31/操作系统思考题/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>操作系统思考题 | My Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/操作系统思考题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">操作系统思考题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-31 10:46:17 / 修改时间：10:46:54" itemprop="dateCreated datePublished" datetime="2019-10-31T10:46:17+08:00">2019-10-31</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>第一次思考题：</strong></p>
<p><strong>1，为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？</strong></p>
<p>   因为CPU只能运行内存中的程序，而在计算机启动最开始的时候，RAM中什么都没有，操作系统代码存放在软盘中，无法直接运行；BIOS代码的执行是靠硬件实现的，它被固化在计算机中的ROM芯片里。</p>
<p><strong>2，为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？</strong></p>
<p>int 0x19中断向量是由BIOS执行的，只负责将第一扇区加载到0x07C00位置；</p>
<p>而int 0x13中断向量是由bootsect执行的，它可以按照设计者的意图，把指定扇区加载到内存的指定位置。</p>
<p><strong>3，为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？</strong></p>
<p>因为BIOS程序在内存最开始的位置（0x00000）构建了中断向量表和BIOS数据区，如果把bootsect加载到此位置会将之前的内容覆盖；</p>
<p>因为执行setup.s的时候，会将system移动到内存地址的起始位置，将bootsect.s覆盖掉；</p>
<p>bootsect的加载位置是由BIOS决定的，只能首先加载到0x07C00位置。</p>
<p><strong>4，bootsect、setup、head程序之间是怎么衔接的？给出代码证据。</strong></p>
<p>bootsect通过int 0x13中断加载setup、head程序到内存中；</p>
<p>bootsect.s执行完成之后，跳转到setup.s执行，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmpi <span class="number">0</span>,SETUPSEG</span><br></pre></td></tr></table></figure>
<p>setup.s执行完成之后，跳转到head.s执行，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmpi <span class="number">0</span>,<span class="number">8</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">现在已经将 system 模块移动到 0x00000 开始的地方，所以这里的偏移地址是 0。这里的段值的 8 已经是保护模式下的段选择符了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以段选择符8(01000)表示请求特权级 0、使用GDT的第 1 项，该项指出代码的基地址是 0，因此这里的跳转指令就会去执行 system 中的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而head.s就位于system的最开始。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>5，setup程序里的cli是为了什么？</strong></p>
<p>执行setup程序的时候，会将system程序移动到内存最开始的位置（0x00000），也就废除原来实模式下的中断机制，并且会为建立新的保护模式下的中断机制做准备，在新的中断机制完全建立之前，系统不允许响应中断，所以这里采取了关中断的措施。</p>
<p><strong>6，setup程序的最后是jmpi 0,8 为什么这个8不能简单的当作阿拉伯数字8看待？</strong></p>
<p>这里的段值的 8 已经是保护模式下的段选择符了，所以不能简单的当作阿拉伯数字8看待。段选择符8(01000)中的最后两位（00）表示请求内核特权级 、第三位（0）表示GDT，前两位（01）表示所选表的1项（即第2项）来确定代码段的段基址和段限长等。</p>
<p><strong>7，打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？</strong></p>
<p>A20如果没有打开，则计算机处于20位的寻址模式，超过0xFFFFF寻址必然“回滚”；打开A20意味着CPU可以进行32位寻址，最大寻址空间4GB。</p>
<p>打开pe是使能保护模式，也就是说，打开pe的前提是打开A20，但是打开A20不一定要打开pe。</p>
<p><strong>8，在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？</strong></p>
<p>首先，刚刚由实模式转变到保护模式时，执行head.s需要使用setup程序设置的GDT寻址；</p>
<p>其次，将来在设计缓存区时会覆盖原来setup模块所在的位置，所以需要重新设置一套GDT，现在内存中唯一安全的地方就是head.s所在的位置；</p>
<p>最后，也不可能在执行setup程序的时候把GDT的内容复制到head.s的位置。因为如果先复制GDT，再移动system，它就会被后者覆盖；如果先移动system，然后复制GDT，它又会把head.s对应的程序覆盖。</p>
<p><strong>9，Linux是用C语言写的，为什么没有从main开始，而是先运行3个汇编程序，道理何在？</strong></p>
<p>通常，用C语言编写的程序都是用户应用程序，这类程序必须在操作系统的平台上执行，要由操作系统为应用程序创建进程，并把应用程序的可执行代码从硬盘加载到内存。</p>
<p>加载操作系统的时候，计算机刚刚加电，只有BIOS程序在运行，而且计算机处于16位的实模式状态，只有先运行bootsect.s、setup.s、head.s三个汇编程序后，打开A20、打开pe、pg，废除16位的中断机制、建立32位的IDT，计算机才处于32位的保护模式状态，再调用32位main函数执行。</p>
<p><strong>10，为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。</strong></p>
<p>call指令会将EIP的值自动压栈，保护返回现场，然后执行被调函数的程序。等到执行被调函数的ret指令时，自动出栈给EIP并还原现场，继续执行call的下一条指令。</p>
<p>但是对于操作系统的main函数来说，如果通过call调用了main函数，因为操作系统已经是最底层的系统了，那么ret返回的时候逻辑上就说不通了；所以，操作系统采用了手动编写代码压栈和跳转，用ret实现调用main函数的方式。</p>
<p><img src="C:\Users\我的电脑\AppData\Roaming\Typora\typora-user-images\1571904362530.png" alt="1571904362530"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    pushl $<span class="number">0</span>  </span><br><span class="line">    pushl $<span class="number">0</span> </span><br><span class="line">    pushl $<span class="number">0</span> </span><br><span class="line">    pushl $L6 </span><br><span class="line">    pushl $_main </span><br><span class="line">    jmp setup_paging </span><br><span class="line"> </span><br><span class="line">setup_paging:</span><br><span class="line">    ...</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>注意：压栈的EIP值是main函数的入口地址_main。</p>
<p><strong>下面两题参考IA-32-3中文版.pdf</strong><br><strong>11，保护模式的“保护”体现在哪里？</strong></p>
<p>根据特权级别的不同，保护机制提供了对特定段或者页进行限制性访问的能力。比如，可以将重要的操作系统代码和数据放在特权级更高的段上来保护它们，这样，处理器的保护机制就可以防止应用程序代码不加控制地访问操作系统的代码和数据。</p>
<p>当使用保护机制时，对内存的任何引用都要进行检验，以确定是否符合各种保护<br>性要求。这些检验都是在内存周期开始之前进行的，任何违例都会导致异常的产生。</p>
<p>保护性检验可以分为如下几类：界限检验，类型检验，特权级检验，可寻址区域的限制，例程入口点的限制，指令集的限制。 </p>
<p><strong>12，特权级的目的和意义是什么？为什么特权级是基于段的？</strong></p>
<p>特权级是操作系统为了更好地管理内存空间及其访问控制而设的，提高了系统的安全性。</p>
<p>分段提供了一个隔离每个进程或任务代码、数据和栈模块的机制，保证了多个进程或任务能够同一个处理器上运行而不会互相干扰。特权级基于段，给段不同的特权级，就会保证进程不能越级访问。</p>
<p><strong>第二次思考题：</strong></p>
<p><strong>1、进程0的task_struct、内核栈、用户栈在哪？证明进程0的用户栈就是未激活进程0时的0特权栈，即user_stack，而进程0的内核栈并不是user_stack，给出代码证据。</strong></p>
<p>进程0的task_struct位于内核数据段，而进程0的内核栈就位于task数据结构所在页面的末端（共同构成task_union,4KB,正好一页）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel/sched.c:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> task_union init_task = &#123;INIT_TASK,&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">include/linux/sched.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK ... <span class="comment">//初始化进程0的task</span></span></span><br></pre></td></tr></table></figure>
<p>进程0的用户栈就是user_stack，代码如下，因为当进程0由0特权翻转到3特权时，压栈的为内核栈的SS、EIP，所以进程0的用户栈就是内核栈user_stack,这也就是为什么内核栈的名字叫“user_stack”的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line">__asm__ (<span class="string">"movl %%esp,%%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $0x17\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl %%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushfl\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $0x0f\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $1f\n\t"</span> \</span><br><span class="line">	<span class="string">"iret\n"</span> \</span><br></pre></td></tr></table></figure>
<p><strong>2、在system.h里</strong><br><strong>#define _set_gate(gate_addr,type,dpl,addr) \<br><em>asm</em> _(“movw %%dx,%%ax\n\t” \</strong><br>    <strong>“movw %0,%%dx\n\t” \
    </strong>“movl %%eax,%1\n\t” \<br>    <strong>“movl %%edx,%2” \
    </strong>: \<br>    <strong>: “i” ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \
    </strong>“o” (<em>((char </em>) (gate_addr))), \<br>    “o” (<em>(4+(char </em>) (gate_addr))), \<br>    *<em>“d” ((char </em>) (addr)),”a” (0x00080000))</p>
<p><strong>#define set_intr_gate(n,addr) \
    </strong>_set_gate(&amp;idt[n],14,0,addr)</p>
<p><strong>#define set_trap_gate(n,addr) \
    </strong>_set_gate(&amp;idt[n],15,0,addr)</p>
<p><strong>#define set_system_gate(n,addr) \
    </strong>_set_gate(&amp;idt[n],15,3,addr)</p>
<p><strong>这里中断门、陷阱门、系统调用都是通过_set_gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。</strong></p>
<p>dpl代表特权级，0代表内核特权级，3代表用户特权级。操作系统不允许用户直接访问内核，而中断门和陷阱门的设置只能在内核中完成，所以特权级为0；但是有些情况下，用户进程又需要内核代码的支持，因此就需要系统调用，它是用户进程与内核打交道的接口，是由用户进程直接调用的，所以特权级为3。</p>
<p><strong>3、进程0 fork进程1之前，为什么先要调用move_to_user_mode()？用的是什么方法？解释其中的道理。</strong></p>
<p>因为Linux操作系统规定，除进程0之外，所有进程都要由一个已有进程在3特权级下创建。而进程0的代码和数据都是由操作系统的设计者写在内核代码、数据区，并且，此前处于0特权级，所以要调用move_to_user_mode()，实现进程0的特权级从0变为3。</p>
<p>模仿中断的保护现场，由硬件完成SS、ESP、EFLAGS、CS、EIP的压栈动作，而且为了实现特权级的翻转，SS、CS的特权级必须是3特权级，最后执行iret出栈恢复现场并返回被中断的程序继续执行。</p>
<p><strong>4、在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0.11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。</strong></p>
<p>cli指令的执行与CPL（当前特权级）和EFLAGS[IOPL]标志位有关。只有CPL&lt;=IOPL才能执行，否则将会产生一个一般性保护异常。</p>
<p>IOPL仅可通过iret来改变，进程0的TSS中将IOPL初始化为0，在move_to_user_mode（）中没有对IOPL的值进行修改，IOPL的值仍然为0没有改变，所以3特权级进程无法调用cli指令。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*tss*/</span>	&#123;<span class="number">0</span>,PAGE_SIZE+(<span class="keyword">long</span>)&amp;init_task,<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">long</span>)&amp;pg_dir,\</span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \    <span class="comment">//EFLAGS的值</span></span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>, \</span><br><span class="line">	 _LDT(<span class="number">0</span>),<span class="number">0x80000000</span>, \</span><br><span class="line">		&#123;&#125; \</span><br><span class="line">	&#125;, \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line">__asm__ (<span class="string">"movl %%esp,%%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $0x17\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl %%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushfl\n\t"</span> \     <span class="comment">//EFLAGS进栈</span></span><br><span class="line">	<span class="string">"pushl $0x0f\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $1f\n\t"</span> \</span><br><span class="line">	<span class="string">"iret\n"</span> \</span><br><span class="line">	...</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p><strong>5、用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？</strong></p>
<p>不可行。首先，用户进程不可以设置GDT、LDT，因为Linux0.11将GDT、LDT这两个数据结构设置在内核数据区，是0特权级的，只有0特权级的代码才能修改设置GDT、LDT；如果仅仅是形式上做一套和GDT、LDT一样的数据结构是可以的，但是真正起作用的GDT、LDT是CPU硬件认定的，这两个数据结构的首地址必须挂载在CPU中的GDTR、LDTR上，运行时CPU只认GDTR和LDTR指向的数据结构，其他数据结构就算起名字叫GDT、LDT，但用户进程不能将自己制作的GDT、LDT挂接到GDTR、LDTR上，CPU也一概不认。</p>
<p><strong>6、分析初始化IDT、GDT、LDT的代码。</strong></p>
<p>（1）初始化IDT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	set_trap_gate(<span class="number">0</span>,&amp;divide_error); <span class="comment">// 设置除零错误的中断向量,以下雷同。</span></span><br><span class="line">	set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">	set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">	set_system_gate(<span class="number">3</span>,&amp;int3);	<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">	set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">	set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">	set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">	set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">	set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">	set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">	set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">	set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">	set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">	set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">	set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">	set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">	set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)<span class="comment">//先均设置为reserved，以后每个硬件初始化时会重新设置</span></span><br><span class="line">		set_trap_gate(i,&amp;reserved);</span><br><span class="line">	set_trap_gate(<span class="number">45</span>,&amp;irq13);<span class="comment">// 协处理器</span></span><br><span class="line">	outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">//允许IRQ2中断请求</span></span><br><span class="line">	outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);<span class="comment">//允许IRQ13中断请求</span></span><br><span class="line">	set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);并口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）初始化GDT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//成对初始化TSSi、LDTi</span></span><br><span class="line">  set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\我的电脑\AppData\Roaming\Typora\typora-user-images\1572108499756.png" alt="1572108499756"></p>
<p>（3）初始化LDT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br></pre></td></tr></table></figure>
<p><strong>7、在sched_init(void)函数中有这样的代码：C</strong><br><strong>for(i=1;i&lt;NR_TASKS;i++) {</strong><br>    <strong>task[i] = NULL;</strong><br>    <strong>……</strong><br><strong>但并未涉及task[0]，从后续代码能感觉到已经给了进程0，请给出代码证据。</strong></p>
<p>代码如下，task[0]已经被init_task.task占用：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] = &#123;</span>&amp;(init_task.task), &#125;;</span><br></pre></td></tr></table></figure>
<p>而init_task.task即为进程0的task：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* pid etc.. */</span>	<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \   <span class="comment">//进程号0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>第三次思考题：</strong></p>
<p><strong>1、进程0 fork进程1之前，为什么先调用move_to_user_mode()？用的是什么方法？解释其中的道理。</strong></p>
<p>重复题目，略。</p>
<p><strong>2、为什么static inline _syscall0(type,name)中加上关键字inline？</strong></p>
<p>由于创建新进程的过程是通过完全复制父进程代码段和数据段的方式实现的，因此在首次使用 fork()创建新进程 init 时，为了确保新进程用户态堆栈没有进程 0 的多余信息，要求进程 0 在创建首个新进程之前不要使用用户态堆栈，也即要求进程 0 不要调用函数。因此在 main.c 主程序移动到进程0 执行后，进程 0 中的代码 fork()不能以函数形式进行调用。程序中实现的方法是采用 gcc 函数内嵌的形式来执行这个系统调用。通过申明一个内嵌函数，可以让 gcc 把函数的代码集成到调用它的代码中。这会提高代码执行<br>的速度，因为省去了函数调用的开销。另外，如果任何一个实际参数是一个常量，那么在编译时这些已知值就可能使得无需把内嵌函数的所有代码都包括进来而让代码也得到简化 。</p>
<p><strong>3、copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。</strong></p>
<p>当执行“int $0x80”时，中断使CPU硬件自动将SS、ESP、EFLAGS、CS、EIP这五个寄存器的数值按顺序压入进程0的内核栈中，之前的move_to_user_mode（）中做的压栈动作就是模仿中断的硬件压栈。</p>
<p><strong>4、打开保护模式、分页后，线性地址到物理地址是如何转换的？</strong></p>
<p>线性地址有32位，CPU将这个线性地址解析为“页目录项”、“页表项”、“页内偏移”。通过线性地址提供的“页目录表项”可以找到页目录表中对应的页目录项，通过这个页目录表项就可以找到对应的页表；通过线性地址提供的“页表项”可以找到该页表中对应的页表项；通过该页表项就可以找到对应的物理页面；最后，通过线性地址提供的“页内偏移”找到实际的物理地址值。</p>
<p><strong>5、分析get_free_page()函数的代码，叙述在主内存中获取一个空闲页的技术路线。</strong></p>
<p>遍历mem_map[ ],从主内存的末端开始向低地址端递进，找到第一个空闲页面，返回该页的起始地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __<span class="function">res <span class="title">asm</span><span class="params">(<span class="string">"ax"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">"std ; repne ; scasb\n\t"</span></span><br><span class="line">	<span class="string">"jne 1f\n\t"</span></span><br><span class="line">	<span class="string">"movb $1,1(%%edi)\n\t"</span></span><br><span class="line">	<span class="string">"sall $12,%%ecx\n\t"</span></span><br><span class="line">	<span class="string">"addl %2,%%ecx\n\t"</span></span><br><span class="line">	<span class="string">"movl %%ecx,%%edx\n\t"</span></span><br><span class="line">	<span class="string">"movl $1024,%%ecx\n\t"</span></span><br><span class="line">	<span class="string">"leal 4092(%%edx),%%edi\n\t"</span></span><br><span class="line">	<span class="string">"rep ; stosl\n\t"</span></span><br><span class="line">	<span class="string">"movl %%edx,%%eax\n"</span></span><br><span class="line">	<span class="string">"1:"</span></span><br><span class="line">	:<span class="string">"=a"</span> (__res)</span><br><span class="line">	:<span class="string">"0"</span> (<span class="number">0</span>),<span class="string">"i"</span> (LOW_MEM),<span class="string">"c"</span> (PAGING_PAGES),</span><br><span class="line">	<span class="string">"D"</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">	:<span class="string">"di"</span>,<span class="string">"cx"</span>,<span class="string">"dx"</span>);</span><br><span class="line"><span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、分析copy_page_tables（）函数的代码，叙述父进程如何为子进程复制页表。</strong></p>
<p>先为新的页表申请一个空闲页面，并把父进程的第一个页表里面的前160个页表项复制到这个页面中（1个页表项控制一个页面4KB内存空间，160个页表项可以控制640KB内存空间）。之后对子进程的页目录表进行设置。最后，用重置CR3的方法刷新页变换高速缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * from_page_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * to_page_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> this_page;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * from_dir, * to_dir;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>))</span><br><span class="line">		panic(<span class="string">"copy_page_tables called with wrong alignment"</span>);</span><br><span class="line">	from_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span></span><br><span class="line">	to_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">	size = ((<span class="keyword">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;</span><br><span class="line">	<span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)</span><br><span class="line">			panic(<span class="string">"copy_page_tables: already exist"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		from_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">		<span class="keyword">if</span> (!(to_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) get_free_page()))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">		*to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) to_page_table) | <span class="number">7</span>;</span><br><span class="line">		nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>;</span><br><span class="line">		<span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">			this_page = *from_page_table;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			this_page &amp;= ~<span class="number">2</span>;</span><br><span class="line">			*to_page_table = this_page;</span><br><span class="line">			<span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">				*from_page_table = this_page;</span><br><span class="line">				this_page -= LOW_MEM;</span><br><span class="line">				this_page &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">				mem_map[this_page]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7、进程0创建进程1时，为进程1建立了task_struct及内核栈，第一个页表，分别位于物理内存16MB顶端倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。</strong></p>
<p>内核的线性地址空间。根据内核分页策略，所有的页面，刚进入保护模式时，就已经映射到了内核的16M线性地址空间。这两个页面都是调用get_free_page()函数获得的，是在内核中执行的，获得的页面只可能在内核的线性地址空间中。在后续的程序中，也没有将这个页面映射到其他进程线性地址空间的代码，因此，只有内核具备访问它的能力。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">	movl $<span class="number">1024</span>*<span class="number">5</span>,%ecx		<span class="comment">/* 5 pages - pg_dir+4 page tables */</span></span><br><span class="line">	xorl %eax,%eax</span><br><span class="line">	xorl %edi,%edi			<span class="comment">/* pg_dir is at 0x000 */</span></span><br><span class="line">	cld;rep;stosl</span><br><span class="line">	movl $pg0+<span class="number">7</span>,_pg_dir		<span class="comment">/* set present bit/user r/w */</span></span><br><span class="line">	movl $pg1+<span class="number">7</span>,_pg_dir+<span class="number">4</span>		<span class="comment">/*  --------- " " --------- */</span></span><br><span class="line">	movl $pg2+<span class="number">7</span>,_pg_dir+<span class="number">8</span>		<span class="comment">/*  --------- " " --------- */</span></span><br><span class="line">	movl $pg3+<span class="number">7</span>,_pg_dir+<span class="number">12</span>		<span class="comment">/*  --------- " " --------- */</span></span><br><span class="line">	movl $pg3+<span class="number">4092</span>,%edi</span><br><span class="line">	movl $<span class="number">0xfff007</span>,%eax		<span class="comment">/*  16Mb - 4096 + 7 (r/w user,p) */</span></span><br><span class="line">	<span class="built_in">std</span></span><br><span class="line"><span class="number">1</span>:	stosl			<span class="comment">/* fill pages backwards - more efficient :-) */</span></span><br><span class="line">	subl $<span class="number">0x1000</span>,%eax</span><br><span class="line">	jge <span class="number">1b</span></span><br><span class="line">	xorl %eax,%eax		<span class="comment">/* pg_dir is at 0x0000 */</span></span><br><span class="line">	movl %eax,%cr3		<span class="comment">/* cr3 - page directory start */</span></span><br><span class="line">	movl %cr0,%eax</span><br><span class="line">	orl $<span class="number">0x80000000</span>,%eax</span><br><span class="line">	movl %eax,%cr0		<span class="comment">/* set paging (PG) bit */</span></span><br><span class="line">	ret			<span class="comment">/* this also flushes prefetch-queue */</span></span><br></pre></td></tr></table></figure>
<p><strong>8、根据代码详细分析，进程0如何根据调度第一次切换到进程1的。</strong></p>
<p>首先，依据task[64]这个结构，第一次遍历所有进程，只要地址指针不为空，就要针对它们的“报警定时值alarm”以及“信号位图signal”进行处理。在当前情况下，这些处理不会产生任何效果，尤其是进程0现在并没有受到任何信号，它的状态是“可中断等待状态”，不可能转变为“就绪态”。</p>
<p>第二次遍历所有进程，比较进程的状态和时间片，找出处在就绪态且counter最大的进程。现在只有进程0和进程1，且进程0是可中断等待状态，不是就绪态，只有进程1处于就绪态，所以执行switch_to（next），切换到进程1去执行。</p>
<p><strong>9、switch_to(n)代码中的”ljmp %0\n\t” 很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m” (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。</strong></p>
<p>ljmp通过CPU的任务门机制并未实际使用任务门，将CPU的各个寄存器值保存在进程0的TSS中，将进程1的TSS数据以及LDT的代码段、数据段描述符数据恢复给CPU的各个寄存器，实现从0特权的内核代码切换到3特权的进程1代码执行。</p>
<p><strong>10、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。</strong></p>
<p>（1）第一次执行fork代码：当执行“int 0x80“中断后，压栈的EIP就是当前指令的下一行，即”if（_res &gt;= 0）“：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">long</span> __res; \</span><br><span class="line">__<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"int $0x80"</span> \</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"=a"</span> (__res) \</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"0"</span> (__NR_##name))</span></span>; \</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \</span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int 0x80执行路线很长，大致线路如下图：</p>
<p><img src="C:\Users\我的电脑\AppData\Roaming\Typora\typora-user-images\image-20191027194859638.png" alt="image-20191027194859638"></p>
<p>_res的值就是eax，是copy_process()的返回值last_pid(1)，即 _res值是1，所以return（type） _res将1返回，！1为假，跳过init（）直接执行了for(;;) pause()。</p>
<p>（2）第二次执行fork代码：ljmp通过CPU任务门机制自动将进程1的TSS的值恢复给CPU，自然将其中的tss.eip恢复给CPU。现在CPU中的EIP指向的就是fork中的if（_res &gt;= 0）这一行，所以进程1要从这一行开始执行。</p>
<p>此时的_res值就是就是进程1的TSS中的eax的值，为固定值0，所以return（type） _res返回0，！0为真，执行init（）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	p-&gt;start_time = jiffies;</span><br><span class="line">	p-&gt;tss.back_link = <span class="number">0</span>;</span><br><span class="line">	p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;</span><br><span class="line">	p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">	p-&gt;tss.eip = eip;  <span class="comment">//即int 0x80压栈时的EIP</span></span><br><span class="line">	p-&gt;tss.eflags = eflags;</span><br><span class="line">	p-&gt;tss.eax = <span class="number">0</span>;  <span class="comment">//固定值</span></span><br><span class="line">	p-&gt;tss.ecx = ecx;</span><br><span class="line">	p-&gt;tss.edx = edx;</span><br><span class="line">	p-&gt;tss.ebx = ebx;</span><br><span class="line">	p-&gt;tss.esp = esp;</span><br><span class="line">	p-&gt;tss.ebp = ebp;</span><br><span class="line">	p-&gt;tss.esi = esi;</span><br><span class="line">	p-&gt;tss.edi = edi;</span><br><span class="line">	p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ds = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.fs = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.gs = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ldt = _LDT(nr);</span><br><span class="line">	p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line">	<span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">"clts ; fnsave %0"</span>::<span class="string">"m"</span> (p-&gt;tss.i387));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>11、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</strong></p>
<p>首先在task[64]中从后往前进行遍历，寻找进程状态为”就绪态“且时间片最大的进程作为下一个要执行的进程。通过调用switch_to（）函数跳转到指定进程。在此过程中，如果发现存在状态为就绪态的进程，但这些进程都没有时间片了，则会从后往前遍历所有进程重新分配时间片。然后重新执行以上步骤。如果在遍历过程中，没有发现处于就绪态的进程，则会跳转到进程0。</p>
<p>在switch_to函数中，如果要跳转的目标进程就是当前进程，则不发生跳转。否则，保存当前进程信息，长跳转到目标进程。</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/31/C语言里的那些不得不说的事情/" rel="next" title="C语言里的那些不得不说的事情">
                <i class="fa fa-chevron-left"></i> C语言里的那些不得不说的事情
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/31/深入理解计算机系统之计算机系统漫游/" rel="prev" title="深入理解计算机系统之计算机系统漫游">
                深入理解计算机系统之计算机系统漫游 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Wang Jian">
            
              <p class="site-author-name" itemprop="name">Wang Jian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Jian</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
