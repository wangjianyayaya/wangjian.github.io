<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="My Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Blog">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>My Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/04/深入理解计算机系统-4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/04/深入理解计算机系统-4/" class="post-title-link" itemprop="http://yoursite.com/index.html">深入理解计算机系统-4</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-04 20:42:03 / 修改时间：23:18:48" itemprop="dateCreated datePublished" datetime="2019-12-04T20:42:03+08:00">2019-12-04</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="程序的机器级表示"><a href="#程序的机器级表示" class="headerlink" title="程序的机器级表示"></a>程序的机器级表示</h1><h3 id="1-x86-64-16个存储64位值的通用目的寄存器。"><a href="#1-x86-64-16个存储64位值的通用目的寄存器。" class="headerlink" title="1.x86-64:16个存储64位值的通用目的寄存器。"></a>1.x86-64:16个存储64位值的通用目的寄存器。</h3><p><img src="/2019/12/04/深入理解计算机系统-4/4-1.png" alt="4-1"></p>
<h3 id="2-操作数格式"><a href="#2-操作数格式" class="headerlink" title="2.操作数格式"></a>2.操作数格式</h3><p><img src="/2019/12/04/深入理解计算机系统-4/4-2.png" alt="4-2"></p>
<h3 id="3-数据传送指令—-MOV类"><a href="#3-数据传送指令—-MOV类" class="headerlink" title="3.数据传送指令—-MOV类"></a>3.数据传送指令—-MOV类</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言代码</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exchange</span><span class="params">(<span class="keyword">long</span> *xp,<span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">long</span> x =*xp;</span><br><span class="line">     *xp = y;</span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//汇编代码</span><br><span class="line">// mov S,D</span><br><span class="line">exchange:</span><br><span class="line">    movq (%rdi),%rax</span><br><span class="line">    movq %rsi,(%rdi)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>像x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存快的多。</p>
<h3 id="4-压入和弹出栈数据"><a href="#4-压入和弹出栈数据" class="headerlink" title="4.压入和弹出栈数据"></a>4.压入和弹出栈数据</h3><p>栈：“后进先出”，栈顶元素是所有栈中元素地址中最低的，栈指针%rsp保存着栈顶元素的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  pushq %rbp</span><br><span class="line">/*</span><br><span class="line">  subq $8,%rsp</span><br><span class="line">  movq %rbp,(%rsp) </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  popq %rax</span><br><span class="line">/*</span><br><span class="line">  movq (%rsp),%rax</span><br><span class="line">  addq $8,%rsp</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h3 id="5-加载有效地址—-leaq"><a href="#5-加载有效地址—-leaq" class="headerlink" title="5.加载有效地址—-leaq"></a>5.加载有效地址—-leaq</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言代码</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">scale</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> t = x+<span class="number">4</span>*y+<span class="number">12</span>*z;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//汇编代码</span><br><span class="line">//leaq S,D      D&lt;-&amp;S</span><br><span class="line">//将有效地址写入目的操作数，并不是内存引用</span><br><span class="line">scale:</span><br><span class="line">  leaq (%rdi,%rsi,4),%rax</span><br><span class="line">  leaq (%rdx,%rdx,2),%rdx</span><br><span class="line">  leaq (%rax,%rdx,4),%rax</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<h3 id="6-移位操作"><a href="#6-移位操作" class="headerlink" title="6.移位操作"></a>6.移位操作</h3><p>算术左移和逻辑左移的效果是一样的。</p>
<p>算术右移高位补符号位，逻辑右移高位直接补0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言代码</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">shift_left4_rightn</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x&lt;&lt;=<span class="number">4</span>;</span><br><span class="line">  x&gt;&gt;=n;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//汇编代码</span><br><span class="line">//n: 4 bytes</span><br><span class="line">shift_left4_rightn:</span><br><span class="line">  movq %rdi,%rax</span><br><span class="line">  salq $4,%rax</span><br><span class="line">  movq %esi,%ecx</span><br><span class="line">  sarq %cl,%rax</span><br></pre></td></tr></table></figure>
<h5 id="讨论："><a href="#讨论：" class="headerlink" title="讨论："></a>讨论：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//清零</span><br><span class="line">//相对 movq $0,%rdx更优，编码字节长度短</span><br><span class="line">xorq  %rdx，%rdx</span><br></pre></td></tr></table></figure>
<h3 id="7-跳转指令的编码"><a href="#7-跳转指令的编码" class="headerlink" title="7.跳转指令的编码"></a>7.跳转指令的编码</h3><p>当执行PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。这要追溯到早期处理器会将更新程序计数器作为执行一条指令的第一步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//反汇编二进制代码</span><br><span class="line">4003fa:  74 02                        je 4003fe</span><br><span class="line">4003fc:  ff d0                        callq *%rax</span><br></pre></td></tr></table></figure>
<p>4003fe  = 0x4003fc + 0x02</p>
<h3 id="8-用条件控制实现条件分支"><a href="#8-用条件控制实现条件分支" class="headerlink" title="8.用条件控制实现条件分支"></a>8.用条件控制实现条件分支</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言if-else模板</span></span><br><span class="line"><span class="keyword">if</span> (test-expr)</span><br><span class="line">    then-statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">else</span>-statement</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用C语法描述控制流</span></span><br><span class="line">  t = test-expr;</span><br><span class="line">  <span class="keyword">if</span> (!t)</span><br><span class="line">      <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">  then-statement</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">  <span class="keyword">else</span>-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C程序代码</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val = x+y+z;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">-3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;Z)</span><br><span class="line">            val = x*y;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val = y*z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;<span class="number">2</span>)</span><br><span class="line">        val = x*z;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//汇编代码</span><br><span class="line">//x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">test:</span><br><span class="line">  leap  (%rdi,%rsi),%rax</span><br><span class="line">  addp  %rdx,%rax</span><br><span class="line">  cmpq  $-3,%rdi</span><br><span class="line">  jge   .L2</span><br><span class="line">  cmpq  %rdx,%rsi</span><br><span class="line">  jge   .L3</span><br><span class="line">  movq  %rdi,%rax</span><br><span class="line">  imulq %rsi,%rax</span><br><span class="line">  ret</span><br><span class="line">.L3:</span><br><span class="line">  movq  %rsi,%rax</span><br><span class="line">  imulq %rdx,%rax</span><br><span class="line">  ret</span><br><span class="line">.L2:</span><br><span class="line">  cmpq  %$2,%rdi</span><br><span class="line">  jle   .L4</span><br><span class="line">  movq  %rdi,%rax</span><br><span class="line">  imulq %rdx,%rax</span><br><span class="line">.L4:</span><br><span class="line">  rep;ret       //当ret指令通过跳转指令到达时，处理器不能正确预测ret指令的目的，rep作为一种空操作插入</span><br></pre></td></tr></table></figure>
<h3 id="9-用条件传送实现条件分支"><a href="#9-用条件传送实现条件分支" class="headerlink" title="9.用条件传送实现条件分支"></a>9.用条件传送实现条件分支</h3><h5 id="条件控制和条件传送："><a href="#条件控制和条件传送：" class="headerlink" title="条件控制和条件传送："></a>条件控制和条件传送：</h5><p>条件控制：当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。</p>
<p>条件传送：计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。</p>
<p><strong>一般情况下，基于条件数据传送的代码会比基于条件控制转移的代码性能要好。</strong>处理器通过流水线获得高性能，通过重叠连续指令的步骤获得高性能，这要求事先确定要执行的指令序列。错误预测一个跳转，需要处理器丢掉它为该跳转指令后所有指令已做的工作，付出大量的时间成本，导致程序性能严重下降。</p>
<p>只能用于非常受限制的情况，但与现代处理器的运行方式更契合。使用条件传送也不是总会提高代码的效率。编译器要考虑浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能（但是很难）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象代码描述</span><br><span class="line">v = then-expr;</span><br><span class="line">ve = else-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line">if(!t) v = ve;</span><br></pre></td></tr></table></figure>
<h3 id="10-循环—-do-while循环"><a href="#10-循环—-do-while循环" class="headerlink" title="10.循环—-do-while循环"></a>10.循环—-do-while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//do-while</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-statement</span><br><span class="line">    <span class="keyword">while</span>(test-expr);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if(t)</span><br><span class="line">        goto loop;</span><br></pre></td></tr></table></figure>
<h3 id="11-循环—-while循环"><a href="#11-循环—-while循环" class="headerlink" title="11.循环—-while循环"></a>11.循环—-while循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while</span></span><br><span class="line"><span class="keyword">while</span>(test-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第一种翻译方法</span><br><span class="line">//-Og</span><br><span class="line">//跳转到中间，jump to middle</span><br><span class="line">    goto test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if(t)</span><br><span class="line">         goto loop;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//第二种翻译方法</span><br><span class="line">//-O1</span><br><span class="line">//guarded-do</span><br><span class="line">t = test-expr;</span><br><span class="line">if(!t)</span><br><span class="line">      goto done;</span><br><span class="line">do</span><br><span class="line">      body-statement</span><br><span class="line">      while(test-expr)</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<h3 id="12-循环—-for循环"><a href="#12-循环—-for循环" class="headerlink" title="12.循环—-for循环"></a>12.循环—-for循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for</span></span><br><span class="line"><span class="keyword">for</span> (init-expr; test-expr; update-expr)</span><br><span class="line">    body-statement</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于，有一个例外？</span></span><br><span class="line">init-expr;</span><br><span class="line"><span class="keyword">while</span> (test-expr)</span><br><span class="line">&#123;</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GCC为for循环产生的代码是while循环的两种翻译之一，这取决于优化的等级。</p>
<h3 id="13-循环—-switch语句"><a href="#13-循环—-switch语句" class="headerlink" title="13.循环—-switch语句"></a>13.循环—-switch语句</h3><p>通过使用跳转表（jump table）使得程序更加高效。跳转表是一个数组，表项i是一个代码段的地址，这个代码段实现当开关索引值等于i时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转目标的指令。与使用一组很长的if-else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C程序代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switcher</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b,<span class="keyword">long</span> c,<span class="keyword">long</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> val;   </span><br><span class="line">    <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            c = b ^ <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            val = c + <span class="number">112</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            val = (c + b) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            val = a;   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            val = b;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//汇编代码</span><br><span class="line">//a in %rdi, b in %rsi, c in %rdx, dest in %rcx</span><br><span class="line">//应该是进行了优化，默认val = a;</span><br><span class="line">//测试证明-O1</span><br><span class="line">switcher:</span><br><span class="line">  cmpq $7,%rdi</span><br><span class="line">  ja   .L2</span><br><span class="line">  jmp  *.L4(,%rdi,8)</span><br><span class="line">  .section           .rodata</span><br><span class="line">.L7:</span><br><span class="line">  xorq  $15,%rsi</span><br><span class="line">  movq  %rsi,%rdx</span><br><span class="line">.L3:</span><br><span class="line">  leaq  112(%rdx),%rdi</span><br><span class="line">  jmp   .L6</span><br><span class="line">.L5:</span><br><span class="line">  leaq  (%rdx,%rsi),%rdi</span><br><span class="line">  salq  $2,%rdi</span><br><span class="line">  jmp   .L6</span><br><span class="line">.L2:</span><br><span class="line">  movq  %rsi,%rdi</span><br><span class="line">.L6:</span><br><span class="line">  movq  %rdi,(%rcx)</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//跳转表</span><br><span class="line">//数组</span><br><span class="line">//每一项是一个代码段的地址</span><br><span class="line">1 .L4:</span><br><span class="line">2    .quad     .L3</span><br><span class="line">3    .quad     .L2</span><br><span class="line">4    .quad     .L5</span><br><span class="line">5    .quad     .L2</span><br><span class="line">6    .quad     .L6</span><br><span class="line">7    .quad     .L7</span><br><span class="line">8    .quad     .L2</span><br><span class="line">9    .quad     .L5</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/30/leetcode-1 two sum C++详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/30/leetcode-1 two sum C++详解/" class="post-title-link" itemprop="http://yoursite.com/index.html">leetcode-1 two sum C++详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-30 17:20:09" itemprop="dateCreated datePublished" datetime="2019-11-30T17:20:09+08:00">2019-11-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-01 14:15:55" itemprop="dateModified" datetime="2019-12-01T14:15:55+08:00">2019-12-01</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-暴力法："><a href="#1-暴力法：" class="headerlink" title="1.暴力法："></a>1.暴力法：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;   <span class="comment">//vector数组作函数返回值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; two_sum;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-1</span>;i++)  <span class="comment">//size()获取vector数组的大小</span></span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;nums.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == nums[i]+nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">           two_sum.push_back(i);</span><br><span class="line">           two_sum.push_back(j);</span><br><span class="line">           <span class="keyword">return</span> two_sum; <span class="comment">//找到即返回，节省时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> two_sum;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2)， 空间复杂度：O(1)。</p>
<p>测试数据：执行用时 :184 ms,内存消耗 :9.1 MB。</p>
<h3 id="2-哈希表（空间换时间）"><a href="#2-哈希表（空间换时间）" class="headerlink" title="2.哈希表（空间换时间）"></a>2.哈希表（空间换时间）</h3><h5 id="遍历两遍哈希表："><a href="#遍历两遍哈希表：" class="headerlink" title="遍历两遍哈希表："></a>遍历两遍哈希表：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; two_sum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//map底层实现为红黑数，undered_map底层实现为哈希表，两者均不能有重复的键，均支持[]运算符</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">    <span class="comment">//使用hash存储数组元素和下标的映射关系</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        hash_map[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//count()，返回的是被查找元素的个数，unorder_map中无重复键，只能为0或1</span></span><br><span class="line">    <span class="comment">//find()，返回的是被查找元素的位置，没有则返回map.end()</span></span><br><span class="line">    <span class="comment">//需要判断是否使用了同一个元素两次</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash_map.count(tmp) &amp;&amp; hash_map[tmp]!= i) </span><br><span class="line">        <span class="comment">// if (hash_map.find(tmp)!= hash_map.end() &amp;&amp; hash_map[tmp]!= i) </span></span><br><span class="line">        &#123;</span><br><span class="line">            two_sum.push_back(i);</span><br><span class="line">            two_sum.push_back(hash_map[tmp]);</span><br><span class="line">            <span class="keyword">return</span> two_sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> two_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)， 空间复杂度：O(n)。</p>
<p>测试数据：执行用时 :12 ms,内存消耗 :10.4MB。</p>
<h5 id="遍历一遍哈希表："><a href="#遍历一遍哈希表：" class="headerlink" title="遍历一遍哈希表："></a>遍历一遍哈希表：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; two_sum;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">    <span class="comment">//边存边找。当找到时，后面的不用再存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = target-nums[i];</span><br><span class="line">        <span class="keyword">if</span> (hash_map.count(tmp))</span><br><span class="line">        <span class="comment">//if (hash_map.find(tmp) != hash_map.end())</span></span><br><span class="line">        &#123;</span><br><span class="line">            two_sum.push_back(hash_map[tmp]);</span><br><span class="line">            two_sum.push_back(i);</span><br><span class="line">            <span class="keyword">return</span> two_sum;</span><br><span class="line">        &#125;</span><br><span class="line">        hash_map[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> two_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)， 空间复杂度：O(n)。</p>
<p>测试数据：执行用时 :12 ms,内存消耗 :10MB。</p>
<h3 id="3-补充知识"><a href="#3-补充知识" class="headerlink" title="3.补充知识"></a>3.补充知识</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> nums[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nums[i]);</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash_map[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,hash_map[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试用例：0 4 3 0</span><br><span class="line">结果输出：3 1 2 3</span><br></pre></td></tr></table></figure>
<p>​        实际上这里的测试用例也就是上面程序的一个测试用例（存在重复数字的情况），可以看到，因为unordered_map中是不存在重复键的，重复数字中的第一个数字的下标会被后面出现的重复数字的下标所覆盖，那么为什么上面的程序依然能找到两个数字的下标呢？</p>
<p>​        原因就是上面程序的查找过程实际上是利用原数组（nums[ ]）和unordered_map(hash_map[ ])协同查找的，只需要在hash_map[ ]中查找一个元素即可。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/操作系统导论-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/操作系统导论-1/" class="post-title-link" itemprop="http://yoursite.com/index.html">操作系统导论-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 23:27:21 / 修改时间：23:28:00" itemprop="dateCreated datePublished" datetime="2019-11-18T23:27:21+08:00">2019-11-18</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>虚拟化（virtualization）、并发（concurrency）、持久性（persistence）</strong></p>
<p>操作系统有时也被称为虚拟机（virtual machine）。</p>
<p>接口（API）、系统调用（system call）、操作系统有时被视为标准库（standard library）。</p>
<p>操作系统有时也被称为资源管理器（resource manage）。</p>
<p>1.虚拟化——虚拟化CPU、虚拟化内存</p>
<p>P6：</p>
<p> <em>assert 的作用是先计算表达式 expression ，如果其值为假（即为0），那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。</em> </p>
<p> C语言中，如果一个指针变量的值为NULL，解引用这个指针时，会导致程序崩溃。（图2.3 L10，L13）</p>
<p>2.并发</p>
<p>P8：</p>
<p>atoi ( ascii to integer)是把字符串转换成整型数的一个函数 。</p>
<p>volatile是一个<strong>类型修饰符</strong>（type specifier），就像我们熟悉的const一样，它是被设计用来修饰被不同线程访问和修改的变量；volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值？</p>
<p>P9：</p>
<p>继上一节的冯·诺伊曼打篮球之后的诙谐幽默？？ 参看注释部分。</p>
<p>3.持久性</p>
<p>管理磁盘的软件称为文件系统（file system）。</p>
<p>日志（journaling）、写时复制（copy-on-write）</p>
<p>4.设计目标</p>
<p>折中？？？</p>
<p>（1）抽象（abstraction）——-让系统方便和易于使用。</p>
<p>（2）高性能（performance）——换言之，最小化操作系统的开销（时间、空间）——–忍受不完美。</p>
<p>（3）在应用程序之间、在OS和应用程序之间提供保护（protection）———隔离（isolation）。</p>
<p>（4）操作系统必须不间断运行——-可靠性（reliability）。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/深入理解计算机系统-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/31/深入理解计算机系统-1/" class="post-title-link" itemprop="http://yoursite.com/index.html">深入理解计算机系统-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-31 10:49:24" itemprop="dateCreated datePublished" datetime="2019-10-31T10:49:24+08:00">2019-10-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 23:23:33" itemprop="dateModified" datetime="2019-12-04T23:23:33+08:00">2019-12-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a><strong>第一章 计算机系统漫游</strong></h2><h3 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h3><ol>
<li><p>只由ASCII字符组成的文件称为<em>文本文件</em>，所有其他文件都称为<em>二进制文件</em>。</p>
</li>
<li><p>C语言是设计用来实现<em>Unix操作系统</em>的；C语言是<em>“古怪的、有缺陷的，但同时也是一个巨大的成功”</em>。</p>
</li>
</ol>
<h3 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h3><ol>
<li>C语言是一种<em>高级程序设计语言</em>，这种形式能够被人读懂，但是为了在系统上运行hello.c程序，每条C语句都要被其他程序转化为<em>低级机器语言指令</em>。这些指令按照可执行目标程序的格式打包，以<em>二进制磁盘文件</em>的形式存放起来。编译过程如下：</li>
</ol>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-1" alt="img"></p>
<p><em>预处理阶段</em>：预处理器（cpp）根据以字符#开头的命令，修改原始C程序；</p>
<p><em>编译阶段</em>：编译器（ccl）将C语言程序翻译成汇编语言程序；</p>
<p><em>汇编阶段</em>：汇编器（as）将汇编语言程序翻译成机器语言指令，并将这些指令打包成可重定位目标程序格式（二进制）；</p>
<p><em>链接阶段</em>：链接器（ld）负责将标准库中的.o文件和我们的程序的.o文件的合并。</p>
<p>下图依次是C语言、汇编语言以及机器语言：</p>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-2" alt="img"></p>
<ol start="2">
<li><p><em>GNU项目</em>：</p>
<p>（1）GCC是GNU（GNU‘s  Not  Unix 的缩写）项目开发的众多工具之一（还包括GDB调试等部件）。</p>
<p>（2）现代开放源码运动思想起源是GNU项目中自由软件（free software）的概念。</p>
<p>（3）Linux如此受欢迎很大程度上也要归功于GNU工具，它们给Linux内核提供了环境。</p>
</li>
</ol>
<h3 id="1-3-了解编译系统如何工作的益处"><a href="#1-3-了解编译系统如何工作的益处" class="headerlink" title="1.3 了解编译系统如何工作的益处"></a>1.3 了解编译系统如何工作的益处</h3><ol>
<li><p>优化程序性能；</p>
<p>（1）switch语句是否比一系列if-else语句高效？</p>
<p>（2）while循环比for循环更有效吗？</p>
<p>（3）指针引用比数组索引更有效吗？</p>
<p>（4）为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快得多呢？</p>
<p>（5）为什么简单地重新排列一下算术表达式中的括号就能让函数运行更快？</p>
</li>
<li><p>理解链接时出现的错误；</p>
<p>（1）链接器报告说它无法解析一个引用是什么意思？</p>
<p>（2）如果你在不同的C文件中定义了名字相同的两个全局变量会发生什么？</p>
<p>（3）静态库和动态库的区别是什么？</p>
<p>（4）我们在命令行上排列库的顺序有什么影响？</p>
<p>（5）为什么有些链接错误直到运行时才会出现？</p>
</li>
<li><p>避免安全漏洞。</p>
</li>
</ol>
<p>​         </p>
<h3 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h3><p>shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</p>
<h4 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h4><p><img src="/2019/10/31/深入理解计算机系统-1/1-3" alt="img"></p>
<ol>
<li><p><em>总线</em>：贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中不尽相同，现在大多数机器字长是4个字节（32位）或者8个字节（64位）。</p>
</li>
<li><p><em>I/O设备</em>：I/O设备是系统与外部世界的联系通道。每个I/O设备都通过一个控制器或者适配器（区别在于封装方式）与I/O总线相连。控制器是I/O设备本身或者系统主板上的芯片组。适配器是一块插在主板插槽上的卡。</p>
</li>
<li><p><em>主存</em>：一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。主存是由一组<em>动态随机存储器</em>（DRAM）芯片组成的。</p>
</li>
<li><p><em>处理器</em>：CPU，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p>
<p>寄存器文件是一个小的存储设备，由一些<em>单个字长</em>的寄存器组成，每个寄存器都有唯一的名字。</p>
<p>ALU计算新的数据和地址值。</p>
</li>
</ol>
<h4 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h4><p><img src="/2019/10/31/深入理解计算机系统-1/1-4.png" alt="1-4"></p>
<ol>
<li>shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输入字符串“./hello”后，shell程序将字符逐一读入寄存器，再把它存放到内存中。</li>
</ol>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-5.png" alt="1-5"></p>
<ol start="2">
<li>当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。shell执行一系列指令加载可执行的hello文件，这些指令将hello目标文件的代码和数据从磁盘复制到主存。利用<em>直接存储器存取</em> 技术，数据可以不通过CPU直接从磁盘到达主存。</li>
</ol>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-6.png" alt="1-6"></p>
<ol start="3">
<li>CPU开始执行hello程序main函数中的机器语言指令，这些指令将要输出的字符串复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。</li>
</ol>
<h3 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h3><p><img src="/2019/10/31/深入理解计算机系统-1/1-7.png" alt="1-7"></p>
<p>根据机械原理，较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。</p>
<p>在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备，存放可能经常访问的数据。</p>
<h3 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h3><p><img src="/2019/10/31/深入理解计算机系统-1/1-8" alt="ae3cb3d12890-8"></p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。</p>
<h3 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h3><p><img src="/2019/10/31/深入理解计算机系统-1/1-9.png" alt="1-9"></p>
<p>所有应用程序对硬件的操作尝试都必须通过操作系统。</p>
<p>操作系统有两个基本功能：</p>
<p>（1）防止硬件被失控的应用程序滥用；</p>
<p>（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</p>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-10.png" alt="1-10"></p>
<h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><p>（1）进程是操作系统对一个正在运行的程序的一种抽象。</p>
<p>（2）并发运行，是说一个进程的指令和另一个进程的指令是交错执行的。</p>
<p>（3）在任何一个时刻，单处理器系统都只能执行一个进程的代码。</p>
<p>（4）操作系统通过进程切换实现交错执行的机制称为上下文切换。操作系统保持跟踪进程运行所需的所有状态信息就是上下文（比如PC和寄存器文件的当前值，以及主存的内容）。进行上下文切换时，需要保存当前进程的上下文，恢复新进程的上下文，新进程就会从它上次停止的地方开始。</p>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-11.png" alt="1-11"></p>
<p>​                                            进程A：shell进程           进程B：hello进程</p>
<p>（5）从一个进程到另一个进程的转换是由操作系统内核管理的。当应用程序需要操作系统的某些操作时，它就需要执行系统调用（system call）指令，将控制权传递给内核。</p>
<p>​    内核不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合。</p>
<h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><p>在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p>
<h4 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h4><p><img src="/2019/10/31/深入理解计算机系统-1/1-12.png" alt="image"></p>
<ol>
<li><p>虚拟内存使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片。</p>
</li>
<li><p>不同进程使用的虚拟地址（也称作线性地址）彼此隔离。一个进程中的代码无法更改正在由另一进程使用的物理内存。</p>
</li>
<li>虚拟地址空间可以大于物理地址空间。可以多个虚拟地址映射到同一物理地址，多为共享库。</li>
</ol>
<h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><p>文件就是字节序列。<em>每个I/O设备，甚至网络，都可以看成文件</em>。</p>
<h3 id="1-8-系统之间通过网络通信"><a href="#1-8-系统之间通过网络通信" class="headerlink" title="1.8 系统之间通过网络通信"></a>1.8 系统之间通过网络通信</h3><p><img src="/2019/10/31/深入理解计算机系统-1/1-13" alt="clipboard.png"></p>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-14" alt="img"></p>
<h3 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h3><h4 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h4><ol>
<li>当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li>
</ol>
<p>$$<br>T(new) = T(old)[(1-a) + a/k]<br>$$</p>
<p>​       其中，a为最初系统某部分所需执行时间与执行该应用程序需要时间的比例，k为该        部分性能提升比例。<br>$$<br>S = T(old)/T(new) = 1/[(1-a) + a/k]<br>$$<br>​       其中，S为加速比。</p>
<ol start="2">
<li>要想显著加速整个系统，必须提升全系统中相当大的部分的速度。</li>
</ol>
<h4 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h4><p>并发指一个同时具有多个活动的系统；并行指的是用并发来使一个系统运行得更快。</p>
<ol>
<li>线程级并发</li>
</ol>
<p>​                  <img src="/2019/10/31/深入理解计算机系统-1/1-15" alt="img"> </p>
<p><img src="/2019/10/31/深入理解计算机系统-1/1-16" alt="img"></p>
<p>超线程，有时称为同时多线程，是一项允许一个CPU执行多个控制流的技术。</p>
<ol start="2">
<li>指令级并行</li>
</ol>
<p>（1）流水线（pipelining）技术，在流水线中，将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行的操作，用来处理不同指令的不同部分。</p>
<p>（2）如果处理器可以达到比一个周期一条指令更快的执行效率，就称之为超标量处理器。</p>
<ol start="3">
<li>单指令、多数据并行（SIMD并行）</li>
</ol>
<p>允许一条指令产生多个可以并行执行的操作就称之为SIMD并行。</p>
<h4 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h4><p><img src="/2019/10/31/深入理解计算机系统-1/1-17" alt="img"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/操作系统思考题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/31/操作系统思考题/" class="post-title-link" itemprop="http://yoursite.com/index.html">操作系统思考题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-31 10:46:17 / 修改时间：10:46:54" itemprop="dateCreated datePublished" datetime="2019-10-31T10:46:17+08:00">2019-10-31</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>第一次思考题：</strong></p>
<p><strong>1，为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？</strong></p>
<p>   因为CPU只能运行内存中的程序，而在计算机启动最开始的时候，RAM中什么都没有，操作系统代码存放在软盘中，无法直接运行；BIOS代码的执行是靠硬件实现的，它被固化在计算机中的ROM芯片里。</p>
<p><strong>2，为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？</strong></p>
<p>int 0x19中断向量是由BIOS执行的，只负责将第一扇区加载到0x07C00位置；</p>
<p>而int 0x13中断向量是由bootsect执行的，它可以按照设计者的意图，把指定扇区加载到内存的指定位置。</p>
<p><strong>3，为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？</strong></p>
<p>因为BIOS程序在内存最开始的位置（0x00000）构建了中断向量表和BIOS数据区，如果把bootsect加载到此位置会将之前的内容覆盖；</p>
<p>因为执行setup.s的时候，会将system移动到内存地址的起始位置，将bootsect.s覆盖掉；</p>
<p>bootsect的加载位置是由BIOS决定的，只能首先加载到0x07C00位置。</p>
<p><strong>4，bootsect、setup、head程序之间是怎么衔接的？给出代码证据。</strong></p>
<p>bootsect通过int 0x13中断加载setup、head程序到内存中；</p>
<p>bootsect.s执行完成之后，跳转到setup.s执行，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmpi <span class="number">0</span>,SETUPSEG</span><br></pre></td></tr></table></figure>
<p>setup.s执行完成之后，跳转到head.s执行，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmpi <span class="number">0</span>,<span class="number">8</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">现在已经将 system 模块移动到 0x00000 开始的地方，所以这里的偏移地址是 0。这里的段值的 8 已经是保护模式下的段选择符了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以段选择符8(01000)表示请求特权级 0、使用GDT的第 1 项，该项指出代码的基地址是 0，因此这里的跳转指令就会去执行 system 中的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">而head.s就位于system的最开始。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>5，setup程序里的cli是为了什么？</strong></p>
<p>执行setup程序的时候，会将system程序移动到内存最开始的位置（0x00000），也就废除原来实模式下的中断机制，并且会为建立新的保护模式下的中断机制做准备，在新的中断机制完全建立之前，系统不允许响应中断，所以这里采取了关中断的措施。</p>
<p><strong>6，setup程序的最后是jmpi 0,8 为什么这个8不能简单的当作阿拉伯数字8看待？</strong></p>
<p>这里的段值的 8 已经是保护模式下的段选择符了，所以不能简单的当作阿拉伯数字8看待。段选择符8(01000)中的最后两位（00）表示请求内核特权级 、第三位（0）表示GDT，前两位（01）表示所选表的1项（即第2项）来确定代码段的段基址和段限长等。</p>
<p><strong>7，打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？</strong></p>
<p>A20如果没有打开，则计算机处于20位的寻址模式，超过0xFFFFF寻址必然“回滚”；打开A20意味着CPU可以进行32位寻址，最大寻址空间4GB。</p>
<p>打开pe是使能保护模式，也就是说，打开pe的前提是打开A20，但是打开A20不一定要打开pe。</p>
<p><strong>8，在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？</strong></p>
<p>首先，刚刚由实模式转变到保护模式时，执行head.s需要使用setup程序设置的GDT寻址；</p>
<p>其次，将来在设计缓存区时会覆盖原来setup模块所在的位置，所以需要重新设置一套GDT，现在内存中唯一安全的地方就是head.s所在的位置；</p>
<p>最后，也不可能在执行setup程序的时候把GDT的内容复制到head.s的位置。因为如果先复制GDT，再移动system，它就会被后者覆盖；如果先移动system，然后复制GDT，它又会把head.s对应的程序覆盖。</p>
<p><strong>9，Linux是用C语言写的，为什么没有从main开始，而是先运行3个汇编程序，道理何在？</strong></p>
<p>通常，用C语言编写的程序都是用户应用程序，这类程序必须在操作系统的平台上执行，要由操作系统为应用程序创建进程，并把应用程序的可执行代码从硬盘加载到内存。</p>
<p>加载操作系统的时候，计算机刚刚加电，只有BIOS程序在运行，而且计算机处于16位的实模式状态，只有先运行bootsect.s、setup.s、head.s三个汇编程序后，打开A20、打开pe、pg，废除16位的中断机制、建立32位的IDT，计算机才处于32位的保护模式状态，再调用32位main函数执行。</p>
<p><strong>10，为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。</strong></p>
<p>call指令会将EIP的值自动压栈，保护返回现场，然后执行被调函数的程序。等到执行被调函数的ret指令时，自动出栈给EIP并还原现场，继续执行call的下一条指令。</p>
<p>但是对于操作系统的main函数来说，如果通过call调用了main函数，因为操作系统已经是最底层的系统了，那么ret返回的时候逻辑上就说不通了；所以，操作系统采用了手动编写代码压栈和跳转，用ret实现调用main函数的方式。</p>
<p><img src="/2019/10/31/操作系统思考题/Users\我的电脑\AppData\Roaming\Typora\typora-user-images\1571904362530.png" alt="1571904362530"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    pushl $<span class="number">0</span>  </span><br><span class="line">    pushl $<span class="number">0</span> </span><br><span class="line">    pushl $<span class="number">0</span> </span><br><span class="line">    pushl $L6 </span><br><span class="line">    pushl $_main </span><br><span class="line">    jmp setup_paging </span><br><span class="line"> </span><br><span class="line">setup_paging:</span><br><span class="line">    ...</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>注意：压栈的EIP值是main函数的入口地址_main。</p>
<p><strong>下面两题参考IA-32-3中文版.pdf</strong><br><strong>11，保护模式的“保护”体现在哪里？</strong></p>
<p>根据特权级别的不同，保护机制提供了对特定段或者页进行限制性访问的能力。比如，可以将重要的操作系统代码和数据放在特权级更高的段上来保护它们，这样，处理器的保护机制就可以防止应用程序代码不加控制地访问操作系统的代码和数据。</p>
<p>当使用保护机制时，对内存的任何引用都要进行检验，以确定是否符合各种保护<br>性要求。这些检验都是在内存周期开始之前进行的，任何违例都会导致异常的产生。</p>
<p>保护性检验可以分为如下几类：界限检验，类型检验，特权级检验，可寻址区域的限制，例程入口点的限制，指令集的限制。 </p>
<p><strong>12，特权级的目的和意义是什么？为什么特权级是基于段的？</strong></p>
<p>特权级是操作系统为了更好地管理内存空间及其访问控制而设的，提高了系统的安全性。</p>
<p>分段提供了一个隔离每个进程或任务代码、数据和栈模块的机制，保证了多个进程或任务能够同一个处理器上运行而不会互相干扰。特权级基于段，给段不同的特权级，就会保证进程不能越级访问。</p>
<p><strong>第二次思考题：</strong></p>
<p><strong>1、进程0的task_struct、内核栈、用户栈在哪？证明进程0的用户栈就是未激活进程0时的0特权栈，即user_stack，而进程0的内核栈并不是user_stack，给出代码证据。</strong></p>
<p>进程0的task_struct位于内核数据段，而进程0的内核栈就位于task数据结构所在页面的末端（共同构成task_union,4KB,正好一页）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel/sched.c:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> task_union init_task = &#123;INIT_TASK,&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">include/linux/sched.h:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK ... <span class="comment">//初始化进程0的task</span></span></span><br></pre></td></tr></table></figure>
<p>进程0的用户栈就是user_stack，代码如下，因为当进程0由0特权翻转到3特权时，压栈的为内核栈的SS、EIP，所以进程0的用户栈就是内核栈user_stack,这也就是为什么内核栈的名字叫“user_stack”的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line">__asm__ (<span class="string">"movl %%esp,%%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $0x17\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl %%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushfl\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $0x0f\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $1f\n\t"</span> \</span><br><span class="line">	<span class="string">"iret\n"</span> \</span><br></pre></td></tr></table></figure>
<p><strong>2、在system.h里</strong><br><strong>#define _set_gate(gate_addr,type,dpl,addr) \<br><em>asm</em> _(“movw %%dx,%%ax\n\t” \</strong><br>    <strong>“movw %0,%%dx\n\t” \
    </strong>“movl %%eax,%1\n\t” \<br>    <strong>“movl %%edx,%2” \
    </strong>: \<br>    <strong>: “i” ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \
    </strong>“o” (<em>((char </em>) (gate_addr))), \<br>    “o” (<em>(4+(char </em>) (gate_addr))), \<br>    *<em>“d” ((char </em>) (addr)),”a” (0x00080000))</p>
<p><strong>#define set_intr_gate(n,addr) \
    </strong>_set_gate(&amp;idt[n],14,0,addr)</p>
<p><strong>#define set_trap_gate(n,addr) \
    </strong>_set_gate(&amp;idt[n],15,0,addr)</p>
<p><strong>#define set_system_gate(n,addr) \
    </strong>_set_gate(&amp;idt[n],15,3,addr)</p>
<p><strong>这里中断门、陷阱门、系统调用都是通过_set_gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。</strong></p>
<p>dpl代表特权级，0代表内核特权级，3代表用户特权级。操作系统不允许用户直接访问内核，而中断门和陷阱门的设置只能在内核中完成，所以特权级为0；但是有些情况下，用户进程又需要内核代码的支持，因此就需要系统调用，它是用户进程与内核打交道的接口，是由用户进程直接调用的，所以特权级为3。</p>
<p><strong>3、进程0 fork进程1之前，为什么先要调用move_to_user_mode()？用的是什么方法？解释其中的道理。</strong></p>
<p>因为Linux操作系统规定，除进程0之外，所有进程都要由一个已有进程在3特权级下创建。而进程0的代码和数据都是由操作系统的设计者写在内核代码、数据区，并且，此前处于0特权级，所以要调用move_to_user_mode()，实现进程0的特权级从0变为3。</p>
<p>模仿中断的保护现场，由硬件完成SS、ESP、EFLAGS、CS、EIP的压栈动作，而且为了实现特权级的翻转，SS、CS的特权级必须是3特权级，最后执行iret出栈恢复现场并返回被中断的程序继续执行。</p>
<p><strong>4、在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0.11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。</strong></p>
<p>cli指令的执行与CPL（当前特权级）和EFLAGS[IOPL]标志位有关。只有CPL&lt;=IOPL才能执行，否则将会产生一个一般性保护异常。</p>
<p>IOPL仅可通过iret来改变，进程0的TSS中将IOPL初始化为0，在move_to_user_mode（）中没有对IOPL的值进行修改，IOPL的值仍然为0没有改变，所以3特权级进程无法调用cli指令。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/*tss*/</span>	&#123;<span class="number">0</span>,PAGE_SIZE+(<span class="keyword">long</span>)&amp;init_task,<span class="number">0x10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">long</span>)&amp;pg_dir,\</span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \    <span class="comment">//EFLAGS的值</span></span><br><span class="line">	 <span class="number">0</span>,<span class="number">0</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>,<span class="number">0x17</span>, \</span><br><span class="line">	 _LDT(<span class="number">0</span>),<span class="number">0x80000000</span>, \</span><br><span class="line">		&#123;&#125; \</span><br><span class="line">	&#125;, \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> move_to_user_mode() \</span></span><br><span class="line">__asm__ (<span class="string">"movl %%esp,%%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $0x17\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl %%eax\n\t"</span> \</span><br><span class="line">	<span class="string">"pushfl\n\t"</span> \     <span class="comment">//EFLAGS进栈</span></span><br><span class="line">	<span class="string">"pushl $0x0f\n\t"</span> \</span><br><span class="line">	<span class="string">"pushl $1f\n\t"</span> \</span><br><span class="line">	<span class="string">"iret\n"</span> \</span><br><span class="line">	...</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p><strong>5、用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？</strong></p>
<p>不可行。首先，用户进程不可以设置GDT、LDT，因为Linux0.11将GDT、LDT这两个数据结构设置在内核数据区，是0特权级的，只有0特权级的代码才能修改设置GDT、LDT；如果仅仅是形式上做一套和GDT、LDT一样的数据结构是可以的，但是真正起作用的GDT、LDT是CPU硬件认定的，这两个数据结构的首地址必须挂载在CPU中的GDTR、LDTR上，运行时CPU只认GDTR和LDTR指向的数据结构，其他数据结构就算起名字叫GDT、LDT，但用户进程不能将自己制作的GDT、LDT挂接到GDTR、LDTR上，CPU也一概不认。</p>
<p><strong>6、分析初始化IDT、GDT、LDT的代码。</strong></p>
<p>（1）初始化IDT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	set_trap_gate(<span class="number">0</span>,&amp;divide_error); <span class="comment">// 设置除零错误的中断向量,以下雷同。</span></span><br><span class="line">	set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">	set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">	set_system_gate(<span class="number">3</span>,&amp;int3);	<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">	set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">	set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">	set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">	set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">	set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">	set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">	set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">	set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">	set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">	set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">	set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">	set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">	set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)<span class="comment">//先均设置为reserved，以后每个硬件初始化时会重新设置</span></span><br><span class="line">		set_trap_gate(i,&amp;reserved);</span><br><span class="line">	set_trap_gate(<span class="number">45</span>,&amp;irq13);<span class="comment">// 协处理器</span></span><br><span class="line">	outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">//允许IRQ2中断请求</span></span><br><span class="line">	outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);<span class="comment">//允许IRQ13中断请求</span></span><br><span class="line">	set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);并口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）初始化GDT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//成对初始化TSSi、LDTi</span></span><br><span class="line">  set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/31/操作系统思考题/Users\我的电脑\AppData\Roaming\Typora\typora-user-images\1572108499756.png" alt="1572108499756"></p>
<p>（3）初始化LDT：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br></pre></td></tr></table></figure>
<p><strong>7、在sched_init(void)函数中有这样的代码：C</strong><br><strong>for(i=1;i&lt;NR_TASKS;i++) {</strong><br>    <strong>task[i] = NULL;</strong><br>    <strong>……</strong><br><strong>但并未涉及task[0]，从后续代码能感觉到已经给了进程0，请给出代码证据。</strong></p>
<p>代码如下，task[0]已经被init_task.task占用：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] = &#123;</span>&amp;(init_task.task), &#125;;</span><br></pre></td></tr></table></figure>
<p>而init_task.task即为进程0的task：</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* pid etc.. */</span>	<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \   <span class="comment">//进程号0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>第三次思考题：</strong></p>
<p><strong>1、进程0 fork进程1之前，为什么先调用move_to_user_mode()？用的是什么方法？解释其中的道理。</strong></p>
<p>重复题目，略。</p>
<p><strong>2、为什么static inline _syscall0(type,name)中加上关键字inline？</strong></p>
<p>由于创建新进程的过程是通过完全复制父进程代码段和数据段的方式实现的，因此在首次使用 fork()创建新进程 init 时，为了确保新进程用户态堆栈没有进程 0 的多余信息，要求进程 0 在创建首个新进程之前不要使用用户态堆栈，也即要求进程 0 不要调用函数。因此在 main.c 主程序移动到进程0 执行后，进程 0 中的代码 fork()不能以函数形式进行调用。程序中实现的方法是采用 gcc 函数内嵌的形式来执行这个系统调用。通过申明一个内嵌函数，可以让 gcc 把函数的代码集成到调用它的代码中。这会提高代码执行<br>的速度，因为省去了函数调用的开销。另外，如果任何一个实际参数是一个常量，那么在编译时这些已知值就可能使得无需把内嵌函数的所有代码都包括进来而让代码也得到简化 。</p>
<p><strong>3、copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。</strong></p>
<p>当执行“int $0x80”时，中断使CPU硬件自动将SS、ESP、EFLAGS、CS、EIP这五个寄存器的数值按顺序压入进程0的内核栈中，之前的move_to_user_mode（）中做的压栈动作就是模仿中断的硬件压栈。</p>
<p><strong>4、打开保护模式、分页后，线性地址到物理地址是如何转换的？</strong></p>
<p>线性地址有32位，CPU将这个线性地址解析为“页目录项”、“页表项”、“页内偏移”。通过线性地址提供的“页目录表项”可以找到页目录表中对应的页目录项，通过这个页目录表项就可以找到对应的页表；通过线性地址提供的“页表项”可以找到该页表中对应的页表项；通过该页表项就可以找到对应的物理页面；最后，通过线性地址提供的“页内偏移”找到实际的物理地址值。</p>
<p><strong>5、分析get_free_page()函数的代码，叙述在主内存中获取一个空闲页的技术路线。</strong></p>
<p>遍历mem_map[ ],从主内存的末端开始向低地址端递进，找到第一个空闲页面，返回该页的起始地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __<span class="function">res <span class="title">asm</span><span class="params">(<span class="string">"ax"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">"std ; repne ; scasb\n\t"</span></span><br><span class="line">	<span class="string">"jne 1f\n\t"</span></span><br><span class="line">	<span class="string">"movb $1,1(%%edi)\n\t"</span></span><br><span class="line">	<span class="string">"sall $12,%%ecx\n\t"</span></span><br><span class="line">	<span class="string">"addl %2,%%ecx\n\t"</span></span><br><span class="line">	<span class="string">"movl %%ecx,%%edx\n\t"</span></span><br><span class="line">	<span class="string">"movl $1024,%%ecx\n\t"</span></span><br><span class="line">	<span class="string">"leal 4092(%%edx),%%edi\n\t"</span></span><br><span class="line">	<span class="string">"rep ; stosl\n\t"</span></span><br><span class="line">	<span class="string">"movl %%edx,%%eax\n"</span></span><br><span class="line">	<span class="string">"1:"</span></span><br><span class="line">	:<span class="string">"=a"</span> (__res)</span><br><span class="line">	:<span class="string">"0"</span> (<span class="number">0</span>),<span class="string">"i"</span> (LOW_MEM),<span class="string">"c"</span> (PAGING_PAGES),</span><br><span class="line">	<span class="string">"D"</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">	:<span class="string">"di"</span>,<span class="string">"cx"</span>,<span class="string">"dx"</span>);</span><br><span class="line"><span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、分析copy_page_tables（）函数的代码，叙述父进程如何为子进程复制页表。</strong></p>
<p>先为新的页表申请一个空闲页面，并把父进程的第一个页表里面的前160个页表项复制到这个页面中（1个页表项控制一个页面4KB内存空间，160个页表项可以控制640KB内存空间）。之后对子进程的页目录表进行设置。最后，用重置CR3的方法刷新页变换高速缓存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * from_page_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * to_page_table;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> this_page;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> * from_dir, * to_dir;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>))</span><br><span class="line">		panic(<span class="string">"copy_page_tables called with wrong alignment"</span>);</span><br><span class="line">	from_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">/* _pg_dir = 0 */</span></span><br><span class="line">	to_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">	size = ((<span class="keyword">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;</span><br><span class="line">	<span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)</span><br><span class="line">			panic(<span class="string">"copy_page_tables: already exist"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		from_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line">		<span class="keyword">if</span> (!(to_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) get_free_page()))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">/* Out of memory, see freeing */</span></span><br><span class="line">		*to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) to_page_table) | <span class="number">7</span>;</span><br><span class="line">		nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>;</span><br><span class="line">		<span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">			this_page = *from_page_table;</span><br><span class="line">			<span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			this_page &amp;= ~<span class="number">2</span>;</span><br><span class="line">			*to_page_table = this_page;</span><br><span class="line">			<span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">				*from_page_table = this_page;</span><br><span class="line">				this_page -= LOW_MEM;</span><br><span class="line">				this_page &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">				mem_map[this_page]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7、进程0创建进程1时，为进程1建立了task_struct及内核栈，第一个页表，分别位于物理内存16MB顶端倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。</strong></p>
<p>内核的线性地址空间。根据内核分页策略，所有的页面，刚进入保护模式时，就已经映射到了内核的16M线性地址空间。这两个页面都是调用get_free_page()函数获得的，是在内核中执行的，获得的页面只可能在内核的线性地址空间中。在后续的程序中，也没有将这个页面映射到其他进程线性地址空间的代码，因此，只有内核具备访问它的能力。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">	movl $<span class="number">1024</span>*<span class="number">5</span>,%ecx		<span class="comment">/* 5 pages - pg_dir+4 page tables */</span></span><br><span class="line">	xorl %eax,%eax</span><br><span class="line">	xorl %edi,%edi			<span class="comment">/* pg_dir is at 0x000 */</span></span><br><span class="line">	cld;rep;stosl</span><br><span class="line">	movl $pg0+<span class="number">7</span>,_pg_dir		<span class="comment">/* set present bit/user r/w */</span></span><br><span class="line">	movl $pg1+<span class="number">7</span>,_pg_dir+<span class="number">4</span>		<span class="comment">/*  --------- " " --------- */</span></span><br><span class="line">	movl $pg2+<span class="number">7</span>,_pg_dir+<span class="number">8</span>		<span class="comment">/*  --------- " " --------- */</span></span><br><span class="line">	movl $pg3+<span class="number">7</span>,_pg_dir+<span class="number">12</span>		<span class="comment">/*  --------- " " --------- */</span></span><br><span class="line">	movl $pg3+<span class="number">4092</span>,%edi</span><br><span class="line">	movl $<span class="number">0xfff007</span>,%eax		<span class="comment">/*  16Mb - 4096 + 7 (r/w user,p) */</span></span><br><span class="line">	<span class="built_in">std</span></span><br><span class="line"><span class="number">1</span>:	stosl			<span class="comment">/* fill pages backwards - more efficient :-) */</span></span><br><span class="line">	subl $<span class="number">0x1000</span>,%eax</span><br><span class="line">	jge <span class="number">1b</span></span><br><span class="line">	xorl %eax,%eax		<span class="comment">/* pg_dir is at 0x0000 */</span></span><br><span class="line">	movl %eax,%cr3		<span class="comment">/* cr3 - page directory start */</span></span><br><span class="line">	movl %cr0,%eax</span><br><span class="line">	orl $<span class="number">0x80000000</span>,%eax</span><br><span class="line">	movl %eax,%cr0		<span class="comment">/* set paging (PG) bit */</span></span><br><span class="line">	ret			<span class="comment">/* this also flushes prefetch-queue */</span></span><br></pre></td></tr></table></figure>
<p><strong>8、根据代码详细分析，进程0如何根据调度第一次切换到进程1的。</strong></p>
<p>首先，依据task[64]这个结构，第一次遍历所有进程，只要地址指针不为空，就要针对它们的“报警定时值alarm”以及“信号位图signal”进行处理。在当前情况下，这些处理不会产生任何效果，尤其是进程0现在并没有受到任何信号，它的状态是“可中断等待状态”，不可能转变为“就绪态”。</p>
<p>第二次遍历所有进程，比较进程的状态和时间片，找出处在就绪态且counter最大的进程。现在只有进程0和进程1，且进程0是可中断等待状态，不是就绪态，只有进程1处于就绪态，所以执行switch_to（next），切换到进程1去执行。</p>
<p><strong>9、switch_to(n)代码中的”ljmp %0\n\t” 很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m” (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。</strong></p>
<p>ljmp通过CPU的任务门机制并未实际使用任务门，将CPU的各个寄存器值保存在进程0的TSS中，将进程1的TSS数据以及LDT的代码段、数据段描述符数据恢复给CPU的各个寄存器，实现从0特权的内核代码切换到3特权的进程1代码执行。</p>
<p><strong>10、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。</strong></p>
<p>（1）第一次执行fork代码：当执行“int 0x80“中断后，压栈的EIP就是当前指令的下一行，即”if（_res &gt;= 0）“：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line"><span class="keyword">long</span> __res; \</span><br><span class="line">__<span class="function">asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"int $0x80"</span> \</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"=a"</span> (__res) \</span></span></span><br><span class="line"><span class="function"><span class="params">	: <span class="string">"0"</span> (__NR_##name))</span></span>; \</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \</span><br><span class="line">	<span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int 0x80执行路线很长，大致线路如下图：</p>
<p><img src="/2019/10/31/操作系统思考题/Users\我的电脑\AppData\Roaming\Typora\typora-user-images\image-20191027194859638.png" alt="image-20191027194859638"></p>
<p>_res的值就是eax，是copy_process()的返回值last_pid(1)，即 _res值是1，所以return（type） _res将1返回，！1为假，跳过init（）直接执行了for(;;) pause()。</p>
<p>（2）第二次执行fork代码：ljmp通过CPU任务门机制自动将进程1的TSS的值恢复给CPU，自然将其中的tss.eip恢复给CPU。现在CPU中的EIP指向的就是fork中的if（_res &gt;= 0）这一行，所以进程1要从这一行开始执行。</p>
<p>此时的_res值就是就是进程1的TSS中的eax的值，为固定值0，所以return（type） _res返回0，！0为真，执行init（）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	p-&gt;start_time = jiffies;</span><br><span class="line">	p-&gt;tss.back_link = <span class="number">0</span>;</span><br><span class="line">	p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;</span><br><span class="line">	p-&gt;tss.ss0 = <span class="number">0x10</span>;</span><br><span class="line">	p-&gt;tss.eip = eip;  <span class="comment">//即int 0x80压栈时的EIP</span></span><br><span class="line">	p-&gt;tss.eflags = eflags;</span><br><span class="line">	p-&gt;tss.eax = <span class="number">0</span>;  <span class="comment">//固定值</span></span><br><span class="line">	p-&gt;tss.ecx = ecx;</span><br><span class="line">	p-&gt;tss.edx = edx;</span><br><span class="line">	p-&gt;tss.ebx = ebx;</span><br><span class="line">	p-&gt;tss.esp = esp;</span><br><span class="line">	p-&gt;tss.ebp = ebp;</span><br><span class="line">	p-&gt;tss.esi = esi;</span><br><span class="line">	p-&gt;tss.edi = edi;</span><br><span class="line">	p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ds = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.fs = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.gs = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">	p-&gt;tss.ldt = _LDT(nr);</span><br><span class="line">	p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line">	<span class="keyword">if</span> (last_task_used_math == current)</span><br><span class="line">		__asm__(<span class="string">"clts ; fnsave %0"</span>::<span class="string">"m"</span> (p-&gt;tss.i387));</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>11、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</strong></p>
<p>首先在task[64]中从后往前进行遍历，寻找进程状态为”就绪态“且时间片最大的进程作为下一个要执行的进程。通过调用switch_to（）函数跳转到指定进程。在此过程中，如果发现存在状态为就绪态的进程，但这些进程都没有时间片了，则会从后往前遍历所有进程重新分配时间片。然后重新执行以上步骤。如果在遍历过程中，没有发现处于就绪态的进程，则会跳转到进程0。</p>
<p>在switch_to函数中，如果要跳转的目标进程就是当前进程，则不发生跳转。否则，保存当前进程信息，长跳转到目标进程。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/31/C语言里的那些不得不说的事情/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/31/C语言里的那些不得不说的事情/" class="post-title-link" itemprop="http://yoursite.com/index.html">C语言里的那些不得不说的事情</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-31 00:19:52 / 修改时间：00:20:47" itemprop="dateCreated datePublished" datetime="2019-10-31T00:19:52+08:00">2019-10-31</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-二维数组作函数参数的烦恼"><a href="#1-二维数组作函数参数的烦恼" class="headerlink" title="1.二维数组作函数参数的烦恼"></a>1.二维数组作函数参数的烦恼</h3><p>在将二维数组作为函数参数的时候通常需要指定二维数组的列数，因为C语言中二维数组实际上是以一维数组的形式存储的，只有指定了列数，才能确定数组的行数。方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void func（int arr[][3]）</span><br><span class="line"></span><br><span class="line">或者    void  func（int （* arr）[3]）</span><br></pre></td></tr></table></figure>
<p>当n不是固定值时，方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func（int **arr, int m, int n）</span><br></pre></td></tr></table></figure>
<p>但是，在函数func()中，需要以下面的方式表示arr[i] [j] (需要进行强制转换)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（int *）arr+i*n+m</span><br></pre></td></tr></table></figure>
<h3 id="2-防不胜防而又不得不防的野指针"><a href="#2-防不胜防而又不得不防的野指针" class="headerlink" title="2.防不胜防而又不得不防的野指针"></a>2.防不胜防而又不得不防的野指针</h3><h5 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h5><p>（1）指针定义时未被初始化：指针被定义的时候，如果程序不对其进行初始化的话，它会指向随机区域，因为任何指针变量（除了static修饰的指针变量）在被定义的时候是不会被置空的，它的默认值是随机的。</p>
<p>（2）指针被释放时没有被置空：我们在用malloc开辟内存空间时，要检查返回值是否为空，如果为空，则开辟失败；如果不为空，则指针指向的是开辟的内存空间的首地址。指针指向的内存空间在用free()释放后，如果程序员没有对其置空或者其他的赋值操作，就会使其成为一个野指针。</p>
<p>（3）指针操作超越变量作用域：不要返回指向栈内存的指针，因为栈内存在函数结束的时候会被释放。</p>
<h5 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h5><p>野指针的问题在于，指针指向的内存已经无效了，而指针没有被置空，解引用（“*”）一个非空的无效指针是一个未被定义的行为，也就是说不一定导致段错误，野指针很难定位到是哪里出现的问题，在哪里这个指针就失效了，不好查找出错的原因。所以调试起来会很麻烦，有时候会需要很长的时间。</p>
<h5 id="养成良好的习惯："><a href="#养成良好的习惯：" class="headerlink" title="养成良好的习惯："></a>养成良好的习惯：</h5><p>（1）初始化指针时将其置为NULL，之后再对其进行操作。</p>
<p><strong><em>特别注意的是，C语言中，如果一个指针变量的值为NULL，解引用这个指针时，会导致程序崩溃</em></strong>。</p>
<p>在C语言中，NULL的定义为：（void  *）0，NULL的实质就是0，将指针赋初值为NULL，其实就是将指针指向0地址处。0地址是一个特殊地址，这个地址在一般的操作系统中都是不可被访问的，如果没按规章处理就会触发段错误。但实际上空指针是不等于野指针的。</p>
<p>（2）在指针使用完时，将其置为NULL。</p>
<p>说起好习惯，顺便补充一点，判断语句试着把 if（p == NULL）写成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if（ NULL == p ）</span><br></pre></td></tr></table></figure>
<p>以防把“==”写成“=”，编译器不会报错，错误很难检查出来。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/GO语言调用C语言动态库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/01/GO语言调用C语言动态库/" class="post-title-link" itemprop="http://yoursite.com/index.html">GO语言调用C语言动态库</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-01 10:40:34 / 修改时间：15:38:40" itemprop="dateCreated datePublished" datetime="2019-04-01T10:40:34+08:00">2019-04-01</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><strong>hello.c文件</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void hello() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>hello.h头文件</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void hello();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>编译生成libhello.so文件</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -fPIC -shared -o libhello.so</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><p><strong>hello.go文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#cgo CFLAGS: -I./</span><br><span class="line">#cgo LDFLAGS: -L./ -lhello</span><br><span class="line">#include &quot;hello.h&quot; //非标准c头文件，所以用引号</span><br><span class="line">*/</span><br><span class="line">import &quot;C&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    C.hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CFLAGS中的-I（大写的i） 参数表示.h头文件所在的路径；</p>
<p>LDFLAGS中的-L(大写的L) 表示.so文件所在的路径 -l(小写的L) 表示指定该路径下的库名称，比如要使用libhello.so，则只需用-lhello（省略了libhello.so中的lib和.so字符）；</p>
<p>import “C”与上方字段（/ 和 / 之间）不能有空行，C需要大写。</p>
</li>
<li><p><strong>运行hello.go</strong></p>
</li>
</ol>
<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run  hello.go</span><br></pre></td></tr></table></figure>
<p>#<strong>遇到的问题：</strong></p>
<p> error while loading shared libraries: libhello.so: cannot open shared object file: No such file or directory</p>
<p>#<strong>解决办法：</strong></p>
<p>1) 如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令（ldconfig命令的用途, 主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下, 搜索出可共享的动态链接库(格式如lib<em>.so</em>), 进而创建出动态装入程序(ld.so)所需的连接和缓存文件. 缓存文件默认为/etc/ld.so.cache, 此文件保存已排好序的动态链接库名字列表）。</p>
<p>2) 如果共享库文件安装到了/usr/local/lib(很多开源的共享库都会安装到该目录下)或其它”非/lib或/usr/lib”目录下, 那么在执行ldconfig命令前, 还要把新共享库目录加入到共享库配置文件/etc/ld.so.conf中, 如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cat  /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">include ld.so.conf.d/*.conf</span><br><span class="line"></span><br><span class="line"># echo  &quot;/usr/local/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line"># ldconfig</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/用openssl制作Chrome信任的自签名证书/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/27/用openssl制作Chrome信任的自签名证书/" class="post-title-link" itemprop="http://yoursite.com/index.html">用openssl制作Chrome信任的自签名证书</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-27 16:26:34 / 修改时间：16:52:52" itemprop="dateCreated datePublished" datetime="2019-03-27T16:26:34+08:00">2019-03-27</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>系统：CentOS7    （自带openssl）</p>
<p><strong>1.</strong> <strong>使用openssl为ssl证书指定主题备用名称SAN(Subject Alternate Name),通过修改配置文件openssl.cnf实现</strong></p>
<p>[root@localhost~]# cd  /etc/pki/tls</p>
<p>[root@localhost~]# vim  openssl.cnf      </p>
<p># <strong>确保req下存在以下2行（默认第一行是有的，第2行被注释了）</strong><br>[ req ]<br>distinguished_name = req_distinguished_name<br>req_extensions = v3_req</p>
<p># <strong>确保req_distinguished_name下没有 0.xxx 的标签，有的话把0.xxx的0. 去掉</strong><br>[ req_distinguished_name ]<br>countryName              = Country Name (2 letter code)<br>countryName_default = CN<br>stateOrProvinceName             = State or Province Name (full name)<br>stateOrProvinceName_default = ShangHai</p>
<p>localityName              = Locality Name (eg, city)<br>localityName_default = ShangHai<br>organizationalUnitName             = Organizational Unit Name (eg, section)<br>organizationalUnitName_default = Domain Control Validated<br>commonName         = Internet Widgits Ltd<br>commonName_max = 64</p>
<p># <strong>新增最后一行内容 subjectAltName = @alt_names（前2行默认存在）</strong><br>[ v3_req ]<br># Extensions to add to a certificate request<br>basicConstraints = CA:FALSE<br>keyUsage = nonRepudiation, digitalSignature, keyEncipherment<br>subjectAltName = @alt_names</p>
<p># <strong>新增 alt_names,注意括号前后的空格，DNS.x 的数量可以自己加</strong><br>[ alt_names ]<br>DNS.1 = abc.example.com<br>DNS.2 = dfe.example.org<br>DNS.3 = ex.abcexpale.net</p>
<p>保存退出。</p>
<p><strong>2. </strong> <strong>创建私有 CA ，然后用该 CA 给证书进行签名</strong></p>
<p><em>（1）创建CA私钥</em></p>
<p>[root@localhost~]# openssl genrsa  -out ca.key 4096</p>
<p><em>（2）使用配置文件生成 CA 的自签名证书</em></p>
<p>[root@localhost~]# openssl req -new -x509 -days 365 -key ca.key -out ca.crt.pem  -config  /etc/pki/tls/openssl.cnf</p>
<p><em>（3）生成需要颁发证书的私钥</em></p>
<p>[root@localhost~]# openssl genrsa  -out server.key.pem 4096</p>
<p><em>（4）使用配置文件生成要颁发证书的证书签名请求</em></p>
<p>[root@localhost~]# openssl req -new -key server.key.pem -out server.csr  -config  /etc/pki/tls/openssl.cnf</p>
<p><strong>Common Name 这个写主要域名就好了(注意：这个域名也要在openssl.cnf的DNS.x里)</strong></p>
<p><em>（5）使用配置文件，用第二步创建的 CA 证书给第四步生成的签名请求进行签名</em></p>
<p>[root@localhost~]# openssl ca -in server.csr -out server.crt.pem -cert ca.crt.pem -keyfile ca.key -extensions v3_req -config /etc/pki/tls/openssl.cnf</p>
<p><strong>3.</strong> <em>将生成的ca.crt.pem和server.crt.pem（这里我需要pem格式文件，如果不需要生成的时候可以直接生成crt格式文件）名称修改为ca.crt和server.crt添加到Chrome信任的证书里。</em></p>
<p># <strong>生成证书时报错</strong></p>
<p>Sign the certificate? [y/n]:y</p>
<p>failed to update database<br>TXT_DB error number 2</p>
<p># <strong>产生的原因</strong></p>
<p> This thing happens when certificates share common data. You cannot have two<br>certificates that look otherwise the same.</p>
<p> # <strong>解决办法</strong><br>​    1.文本打开修改index.txt.attr<br>​    修改unique_subject = yes为unique_subject = no    </p>
<p>​     2.文本打开index.txt<br>​     删除之前生成的证书内容 </p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/17/好记性不如烂笔头之QUIC学习笔记/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/17/好记性不如烂笔头之QUIC学习笔记/" class="post-title-link" itemprop="http://yoursite.com/index.html">好记性不如烂笔头之QUIC学习笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-17 15:23:45 / 修改时间：18:13:26" itemprop="dateCreated datePublished" datetime="2018-12-17T15:23:45+08:00">2018-12-17</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​        QUIC（Quick  UDP  Internet  Connections），最早由Google提出（gQUIC），后交由IETF进一步发展（iQUIC），在 2018 年  11 月 8 日的 IETF-103 HTTPbis 会议上确认 iQUIC新名称是 HTTP／3。HTTP／3 就是使用 QUIC 进行传输的新 HTTP 版本！</p>
<p>​       <img src="https://blog.cloudflare.com/content/images/2018/07/QUIC-Badge-Dark-RGB-Horiz.png" alt="QUIC-Badge-Dark-RGB-Horiz"></p>
<h2 id="产生背景："><a href="#产生背景：" class="headerlink" title="产生背景："></a><strong>产生背景：</strong></h2><p>​        <em>TCP的瓶颈：</em>  TCP由于基于操作系统内核实现，发展速度极慢，现有的TCP Fast Open实现等等虽然早已存在于标准中但是实际应用情况及其落后，即便除非所有机器的操作系统都更新到最新，否则考虑到兼容性不太可能大范围采用新技术。QUIC直接基于客户端实现，而非基于系统内核，可以进行快速迭代更新，不需要操作系统内核层面的更改。</p>
<p>​         <em>HTTP2.0队头阻塞：</em>   虽然实现了多路复用，但也因此出现了队头阻塞的问题。而队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p>
<p>​         QUIC 协议的主要目的，是为了整合 TCP 协议的可靠性和 UDP 协议的速度和效率。</p>
<h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a><strong>特性：</strong></h2><h3 id="1-内置安全加密，减少握手时间，可实现0-RTT的握手过程"><a href="#1-内置安全加密，减少握手时间，可实现0-RTT的握手过程" class="headerlink" title="1.内置安全加密，减少握手时间，可实现0-RTT的握手过程"></a><strong>1.内置安全加密，减少握手时间，可实现0-RTT的握手过程</strong></h3><p>​        TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。但是 QUIC 的 packet 除了个别报文，所有报文头部都是经过认证的。只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p>
<p><img src="https://static001.infoq.cn/resource/image/99/28/990527acaef2cb0cd1b3da52bf08a928.png" alt="img"></p>
<p>​                                                                             <strong>TCP+TLS1.3+HTTP2</strong></p>
<p><img src="https://static001.infoq.cn/resource/image/cb/53/cbccfb0eec8c8115137778e08ef36353.png" alt="img"></p>
<p>​                                                                                 <strong>QUIC</strong></p>
<p>​        0 RTT 的效果是因为QUIC的客户端会缓存服务器端发的令牌和证书，当有数据需要再次发送的时候，客户端可以直接使用旧的令牌和证书，这样就实现了 0 RTT 了。当令牌失效或者没有缓存的情况下，QUIC还是需要一次握手才能开始传输数据。</p>
<h3 id="2-改进的拥塞控制"><a href="#2-改进的拥塞控制" class="headerlink" title="2.改进的拥塞控制"></a>2.改进的拥塞控制</h3><p>​         QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。</p>
<p>​        <em>单调递增的 Packet Number：</em>  QUIC 是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 TCP 重传的歧义问题。</p>
<p>​         <img src="https://pic2.zhimg.com/v2-8db4c3c378edaac0060b4238e3554091_r.jpg" alt="preview"></p>
<p>​                                                                   <strong>TCP重传歧义</strong></p>
<p><img src="https://pic2.zhimg.com/v2-086cc0ac3b95eb5bfe84a2d87bb2a645_r.jpg" alt="preview"></p>
<p>​                                                                        <strong>QUIC重传没有歧义</strong></p>
<p>​        而重传歧义会导致采样RRT的计算出现问题。</p>
<h3 id="3-没有队头阻塞的多路复用"><a href="#3-没有队头阻塞的多路复用" class="headerlink" title="3.没有队头阻塞的多路复用"></a><strong>3.没有队头阻塞的多路复用</strong></h3><p>​         QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。</p>
<p>​         QUIC 因为是基于UDP的协议，一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。</p>
<h3 id="4-前向纠错"><a href="#4-前向纠错" class="headerlink" title="4.前向纠错"></a><strong>4.前向纠错</strong></h3><p>​        QUIC使用了FEC(前向纠错码)来恢复数据，FEC采用简单异或的方式。前向纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间。</p>
<h3 id="5-连接迁移"><a href="#5-连接迁移" class="headerlink" title="5.连接迁移"></a><strong>5.连接迁移</strong></h3><p>​        一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。当我们使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，就需要重新建立和服务端的 TCP 连接。而 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为Connection ID 来标识，这样就算 IP 或者端口发生变化时，只要Connection ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，也不需要重连。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/你好/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wang Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/05/你好/" class="post-title-link" itemprop="http://yoursite.com/index.html">你好</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 15:46:49" itemprop="dateCreated datePublished" datetime="2018-12-05T15:46:49+08:00">2018-12-05</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Wang Jian">
            
              <p class="site-author-name" itemprop="name">Wang Jian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Jian</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
